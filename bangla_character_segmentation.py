# -*- coding: utf-8 -*-
"""Bangla Character Segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JLjLj7x74BgcPP4cl7jKQ4EoBfuZ5mya
"""

# Commented out IPython magic to ensure Python compatibility.
#Mount drive to get file
from google.colab import drive
drive.mount('/content/drive')
# %cd "/content/drive/My Drive/"

import os
import sys
import datetime
import cv2
from PIL import Image
import numpy as np
from google.colab.patches import cv2_imshow
import glob
import scipy.optimize
import logging
import shutil
import math

m_dir = " " 
dir_path = "Bangla Character Segmentation/"
dwarp_path = " "
line_path = " "

extension = ".jpg"
extension1 = ".png"

#Image Dewarp
def resize_to_screen(src, maxw=1200, maxh=800, copy=False):
    height, width = src.shape[:2]

    scl_x = float(width)/maxw
    scl_y = float(height)/maxh

    scl = int(np.ceil(max(scl_x, scl_y)))

    if (scl > 1.0):
        inv_scl = 1.0/scl
        img = cv2.resize(src, (0, 0), None, inv_scl, inv_scl, cv2.INTER_AREA)
    
    elif copy:
        img = src.copy()
    
    else:
        img = src

    return img


def round_nearest_multiple(i, factor):
    i = int(i)
    rem = i % factor
    if not rem:
        return i
    else:
        return i + factor - rem



def fltp(point):
    return tuple(point.astype(int).flatten())


def draw_correspondences(img, dstpoints, projpts):
    display = img.copy()
    dstpoints = norm2pix(img.shape, dstpoints, True)
    projpts = norm2pix(img.shape, projpts, True)

    for pts, color in [(projpts, (255, 0, 0)),
                       (dstpoints, (0, 0, 255))]:

        for point in pts:
            cv2.circle(display, fltp(point), 3, color, -1, cv2.LINE_AA)

    for point_a, point_b in zip(projpts, dstpoints):
        cv2.line(display, fltp(point_a), fltp(point_b),
                 (255, 255, 255), 1, cv2.LINE_AA)

    return display


def project_xy(xy_coords, pvec):
    alpha, beta = tuple(pvec[CUBIC_IDX])

    poly = np.array([alpha + beta, -2 * alpha - beta, alpha, 0])

    xy_coords = xy_coords.reshape((-1, 2))
    z_coords = np.polyval(poly, xy_coords[:, 0])

    objpoints = np.hstack((xy_coords, z_coords.reshape((-1, 1))))

    image_points, _ = cv2.projectPoints(objpoints, pvec[RVEC_IDX], pvec[TVEC_IDX], K, np.zeros(5))

    return image_points


def project_keypoints(pvec, keypoint_index):
    xy_coords = pvec[keypoint_index]
    xy_coords[0, :] = 0

    return project_xy(xy_coords, pvec)


def box(width, height):
    return np.ones((height, width), dtype=np.uint8)


def get_page_extents(small):
    height, width = small.shape[:2]

    xmin = PAGE_MARGIN_X
    ymin = PAGE_MARGIN_Y
    xmax = width-PAGE_MARGIN_X
    ymax = height-PAGE_MARGIN_Y

    page = np.zeros((height, width), dtype=np.uint8)
    cv2.rectangle(page, (xmin, ymin), (xmax, ymax), (255, 255, 255), -1)

    outline = np.array([[xmin, ymin], [xmin, ymax], [xmax, ymax], [xmax, ymin]])

    return page, outline


def get_mask(name, small, pagemask, masktype):
    sgray = cv2.cvtColor(small, cv2.COLOR_RGB2GRAY)

    if masktype == 'text':
        mask = cv2.adaptiveThreshold(sgray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, ADAPTIVE_WINSZ, 25)
        mask = cv2.dilate(mask, box(9, 1))
        mask = cv2.erode(mask, box(1, 3))

    else:
        mask = cv2.adaptiveThreshold(sgray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, ADAPTIVE_WINSZ, 7)
        mask = cv2.erode(mask, box(3, 1), iterations=3)
        mask = cv2.dilate(mask, box(8, 2))

    return np.minimum(mask, pagemask)


def interval_measure_overlap(int_a, int_b):
    return min(int_a[1], int_b[1]) - max(int_a[0], int_b[0])



def blob_mean_and_tangent(contour):
    moments = cv2.moments(contour)

    area = moments['m00']

    mean_x = moments['m10'] / area
    mean_y = moments['m01'] / area

    moments_matrix = np.array([[moments['mu20'], moments['mu11']], [moments['mu11'], moments['mu02']]]) / area
    _, svd_u, _ = cv2.SVDecomp(moments_matrix)

    center = np.array([mean_x, mean_y])
    tangent = svd_u[:, 0].flatten().copy()

    return center, tangent


class ContourInfo(object):
    def __init__(self, contour, rect, mask):
        self.contour = contour
        self.rect = rect
        self.mask = mask

        self.center, self.tangent = blob_mean_and_tangent(contour)
        self.angle = np.arctan2(self.tangent[1], self.tangent[0])

        clx = [self.proj_x(point) for point in contour]

        lxmin = min(clx)
        lxmax = max(clx)

        self.local_xrng = (lxmin, lxmax)
        self.point0 = self.center + self.tangent * lxmin
        self.point1 = self.center + self.tangent * lxmax

        self.pred = None
        self.succ = None

    def proj_x(self, point):
        return np.dot(self.tangent, point.flatten()-self.center)

    def local_overlap(self, other):
        xmin = self.proj_x(other.point0)
        xmax = self.proj_x(other.point1)
        return interval_measure_overlap(self.local_xrng, (xmin, xmax))


def generate_candidate_edge(cinfo_a, cinfo_b):
    if cinfo_a.point0[0] > cinfo_b.point1[0]:
        tmp = cinfo_a
        cinfo_a = cinfo_b
        cinfo_b = tmp

    x_overlap_a = cinfo_a.local_overlap(cinfo_b)
    x_overlap_b = cinfo_b.local_overlap(cinfo_a)

    overall_tangent = cinfo_b.center - cinfo_a.center
    overall_angle = np.arctan2(overall_tangent[1], overall_tangent[0])

    delta_angle = max(angle_dist(cinfo_a.angle, overall_angle), angle_dist(cinfo_b.angle, overall_angle)) * 180/np.pi

    # we want the largest overlap in x to be small
    x_overlap = max(x_overlap_a, x_overlap_b)

    dist = np.linalg.norm(cinfo_b.point0 - cinfo_a.point1)

    if ((dist > EDGE_MAX_LENGTH) or (x_overlap > EDGE_MAX_OVERLAP) or (delta_angle > EDGE_MAX_ANGLE)):
        return None
    
    else:
        score = dist + delta_angle*EDGE_ANGLE_COST
        return (score, cinfo_a, cinfo_b)


def make_tight_mask(contour, xmin, ymin, width, height):
    tight_mask = np.zeros((height, width), dtype=np.uint8)
    tight_contour = contour - np.array((xmin, ymin)).reshape((-1, 1, 2))

    cv2.drawContours(tight_mask, [tight_contour], 0, (1, 1, 1), -1)

    return tight_mask


def get_contours(name, small, pagemask, masktype):
    mask = get_mask(name, small, pagemask, masktype)

    contours,_ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

    contours_out = []
    for contour in contours:
        xmin, ymin, width, height = cv2.boundingRect(contour)

        if (width < TEXT_MIN_WIDTH) or (height < TEXT_MIN_HEIGHT) or (width < TEXT_MIN_ASPECT*height):
            continue

        tight_mask = make_tight_mask(contour, xmin, ymin, width, height)

        if (tight_mask.sum(axis=0).max() > TEXT_MAX_THICKNESS):
            continue

        contours_out.append(ContourInfo(contour, (xmin, ymin, width, height), tight_mask))

    return contours_out


def assemble_spans(name, small, pagemask, cinfo_list):
    # sort list
    cinfo_list = sorted(cinfo_list, key=lambda cinfo: cinfo.rect[1])

    # generate all candidate edges
    candidate_edges = []

    for i, cinfo_i in enumerate(cinfo_list):
        for j in range(i):
            edge = generate_candidate_edge(cinfo_i, cinfo_list[j])
            if edge is not None:
                candidate_edges.append(edge)

    # sort candidate edges by score (lower is better)
    candidate_edges.sort()

    # for each candidate edge
    for _, cinfo_a, cinfo_b in candidate_edges:
        if cinfo_a.succ is None and cinfo_b.pred is None:
            cinfo_a.succ = cinfo_b
            cinfo_b.pred = cinfo_a

    # generate list of spans as output
    spans = []

    # until we have removed everything from the list
    while cinfo_list:
        cinfo = cinfo_list[0]

        while cinfo.pred:
            cinfo = cinfo.pred

        cur_span = []
        width = 0.0

        while cinfo:
            # remove from list (sadly making this loop *also* O(n^2)
            cinfo_list.remove(cinfo)
            # add to span
            cur_span.append(cinfo)
            width += cinfo.local_xrng[1] - cinfo.local_xrng[0]
            # set successor
            cinfo = cinfo.succ

        # add if long enough
        if width > SPAN_MIN_WIDTH:
            spans.append(cur_span)

    return spans


def sample_spans(shape, spans):

    span_points = []
    for span in spans:
        contour_points = []
        for cinfo in span:
            yvals = np.arange(cinfo.mask.shape[0]).reshape((-1, 1))
            totals = (yvals * cinfo.mask).sum(axis=0)
            means = totals / cinfo.mask.sum(axis=0)

            xmin, ymin = cinfo.rect[:2]

            step = SPAN_PX_PER_STEP
            start = ((len(means)-1) % step) / 2

            contour_points += [(x+xmin, means[x]+ymin) for x in range(int(start), len(means), step)]

        contour_points = np.array(contour_points, dtype=np.float32).reshape((-1, 1, 2))
        contour_points = pix2norm(shape, contour_points)
        span_points.append(contour_points)

    return span_points


def keypoints_from_samples(name, small, pagemask, page_outline, span_points):
    all_evecs = np.array([[0.0, 0.0]])
    all_weights = 0

    for points in span_points:
        _, evec = cv2.PCACompute(points.reshape((-1, 2)), None, maxComponents=1)
        weight = np.linalg.norm(points[-1] - points[0])

        all_evecs += evec * weight
        all_weights += weight

    evec = all_evecs / all_weights
    x_dir = evec.flatten()

    if (x_dir[0] < 0):
        x_dir = -x_dir

    y_dir = np.array([-x_dir[1], x_dir[0]])

    pagecoords = cv2.convexHull(page_outline)
    pagecoords = pix2norm(pagemask.shape, pagecoords.reshape((-1, 1, 2)))
    pagecoords = pagecoords.reshape((-1, 2))

    px_coords = np.dot(pagecoords, x_dir)
    py_coords = np.dot(pagecoords, y_dir)

    px0 = px_coords.min()
    px1 = px_coords.max()

    py0 = py_coords.min()
    py1 = py_coords.max()

    p00 = px0 * x_dir + py0 * y_dir
    p10 = px1 * x_dir + py0 * y_dir
    p11 = px1 * x_dir + py1 * y_dir
    p01 = px0 * x_dir + py1 * y_dir

    corners = np.vstack((p00, p10, p11, p01)).reshape((-1, 1, 2))

    ycoords = []
    xcoords = []

    for points in span_points:
        pts = points.reshape((-1, 2))
        px_coords = np.dot(pts, x_dir)
        py_coords = np.dot(pts, y_dir)
        ycoords.append(py_coords.mean() - py0)
        xcoords.append(px_coords - px0)

    return corners, np.array(ycoords), xcoords


def imgsize(img):
    height, width = img.shape[:2]
    return '{}x{}'.format(width, height)


def make_keypoint_index(span_counts):
    nspans = len(span_counts)
    npts = sum(span_counts)
    keypoint_index = np.zeros((npts+1, 2), dtype=int)
    start = 1

    for i, count in enumerate(span_counts):
        end = start + count
        keypoint_index[start:start+end, 1] = 8+i
        start = end

    keypoint_index[1:, 0] = np.arange(npts) + 8 + nspans

    return keypoint_index


def optimize_params(name, small, dstpoints, span_counts, params):
    keypoint_index = make_keypoint_index(span_counts)

    def objective(pvec):
        ppts = project_keypoints(pvec, keypoint_index)
        return np.sum((dstpoints - ppts)**2)

    print ('  initial objective is', objective(params))
    print ('  optimizing', len(params), 'parameters...')
    
    start = datetime.datetime.now()
    res = scipy.optimize.minimize(objective, params, method='Powell')
    end = datetime.datetime.now()
    
    print ('  optimization took', round((end-start).total_seconds(), 2), 'sec.')
    print ('  final objective is', res.fun)
    
    params = res.x

    return params


def get_page_dims(corners, rough_dims, params):
    dst_br = corners[2].flatten()
    dims = np.array(rough_dims)

    def objective(dims):
        proj_br = project_xy(dims, params)
        return np.sum((dst_br - proj_br.flatten())**2)

    res = scipy.optimize.minimize(objective, dims, method='Powell')
    dims = res.x

    print ('  got page dims', dims[0], 'x', dims[1])

    return dims


def remap_image(name, img, small, page_dims, params):

    height = 0.5 * page_dims[1] * OUTPUT_ZOOM * img.shape[0]
    height = round_nearest_multiple(height, REMAP_DECIMATE)

    width = round_nearest_multiple(height * page_dims[0] / page_dims[1], REMAP_DECIMATE)

    print ('output will be {}x{}'.format(width, height))

    height_small = height / REMAP_DECIMATE
    width_small = width / REMAP_DECIMATE

    page_x_range = np.linspace(0, page_dims[0], int(width_small))
    page_y_range = np.linspace(0, page_dims[1], int(height_small))

    page_x_coords, page_y_coords = np.meshgrid(page_x_range, page_y_range)
    page_xy_coords = np.hstack((page_x_coords.flatten().reshape((-1, 1)), page_y_coords.flatten().reshape((-1, 1))))
    page_xy_coords = page_xy_coords.astype(np.float32)

    image_points = project_xy(page_xy_coords, params)
    image_points = norm2pix(img.shape, image_points, False)

    image_x_coords = image_points[:, 0, 0].reshape(page_x_coords.shape)
    image_y_coords = image_points[:, 0, 1].reshape(page_y_coords.shape)
    image_x_coords = cv2.resize(image_x_coords, (width, height), interpolation=cv2.INTER_CUBIC)
    image_y_coords = cv2.resize(image_y_coords, (width, height), interpolation=cv2.INTER_CUBIC)
    
    img = cv2.fastNlMeansDenoisingColored (img, None, 10, 10, 7, 21) 
    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

    remapped = cv2.remap(img_gray, image_x_coords, image_y_coords, cv2.INTER_CUBIC, None, cv2.BORDER_REPLICATE)

    thresh = cv2.adaptiveThreshold(remapped, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, ADAPTIVE_WINSZ, 25)
    thresh = cv2.equalizeHist(thresh)

    pil_image = Image.fromarray(thresh)
    pil_image = pil_image.convert('1')

    threshfile = dwarp_path + name + '.png'
    pil_image.save(threshfile, dpi=(OUTPUT_DPI, OUTPUT_DPI))

    return threshfile

def Crop_Image():
    print ("Image Cropping is Succesful")

def Image_dewarp():
    global dwarp_path
    parent_dir = "Bangla Character Segmentation/"
    dwarp_path = os.path.join(parent_dir, "Preprocessed_Images")   
    os.mkdir(dwarp_path) 
    dwarp_path = dwarp_path + '/'

    outfiles = []

    for imgfile in os.listdir(dir_path): 
        print ('Loading images...')

        if imgfile.endswith(extension):
            image = cv2.imread(dir_path + imgfile)
            img = resize_to_screen(image)

            basename = os.path.basename(imgfile)
            name, _ = os.path.splitext(basename)

            print ('loaded', basename, 'with size', imgsize(image))
            print ('and resized to', imgsize(img))

            pagemask, page_outline = get_page_extents(img)
            cinfo_list = get_contours(name, img, pagemask, 'text')
     

            if (len(spans) < 3):
                print ('  detecting lines because only', len(spans), 'text spans')
                cinfo_list = get_contours(name, img, pagemask, 'line')

                spans2 = assemble_spans(name, img, pagemask, cinfo_list)

                if (len(spans2) > len(spans)):
                    spans = spans2

            if (len(spans) < 1):
                print ('skipping', name, 'because only', len(spans), 'spans')
                continue

            span_points = sample_spans(img.shape, spans)

            print ('  got', len(spans), 'spans')
            print ('with', sum([len(pts) for pts in span_points]), 'points.')

            corners, ycoords, xcoords = keypoints_from_samples(name, img, pagemask, page_outline, span_points)
            rough_dims, span_counts, params = get_default_params(corners, ycoords, xcoords)
            dstpoints = np.vstack((corners[0].reshape((1, 1, 2)),) + tuple(span_points))
            params = optimize_params(name, img, dstpoints, span_counts, params)
            page_dims = get_page_dims(corners, rough_dims, params)

            outfile = remap_image(name, image, img, page_dims, params)
            print ('wrote', outfile)

#Line Segmentation
def Line_Segmentation():
    for image_file in glob.iglob (dwarp_path + '*.png'):
        image = cv2.imread (image_file,  cv2.IMREAD_UNCHANGED)
        LineArray = image
        #print ("Original Binarized Image Array:", LineArray)

        basename = os.path.basename(image_file)
        name, _ = os.path.splitext(basename)

        parent_dir = "Bangla Character Segmentation/"
        global m_dir
        m_dir = os.path.join(parent_dir, name)   
        os.mkdir(m_dir)
        m_dir = m_dir + '/' 

        global line_path
        line_path = os.path.join(m_dir, "Lines")   
        os.mkdir(line_path) 
        line_path = line_path + '/'

        #Converting Black Pixels Value To 1 And White Pixel Values To Zero
        for x in range (LineArray.shape[0]):
            for y in range (LineArray.shape[1]):
                if LineArray[x][y] == 255:
                    LineArray[x][y] = 0
                else:
                    LineArray[x][y] = 1

        Sum_of_row = (np.sum (LineArray, axis=1))
        #print ("\nSum Of Each Row:", Sum_of_row)

        SubArrayOfLine = np.zeros((1, LineArray.shape[1]))
        #print("\nSub Array Of Line:", SubArrayOfLine)
        
        line = 1
        for i in range(LineArray.shape[0]):
            #Checking The Sum Of Row Being 0 To Seperate The Line Or Else Append The Pixels
            if (Sum_of_row[i] != 0):
                SubArrayOfLine = np.append (SubArrayOfLine, LineArray[i:i + 1, :], axis=0)
                    for x in range (SubArrayOfLine.shape[0]):
                        for y in range (SubArrayOfLine.shape[1]):
                            if SubArrayOfLine[x][y] == 0:
                              SubArrayOfLine[x][y] = 255
                            else:
                              SubArrayOfLine[x][y] = 0

                    #Saving Each Segmented Lines Separately And Sequentially
                    pil_image = Image.fromarray(SubArrayOfLine)
                    pil_image = pil_image.convert('1')
                    linefile = line_path + 'line' + str(line) + '.png'
                    pil_image.save(linefile, dpi=(OUTPUT_DPI, OUTPUT_DPI))
                    
                    line = line + 1
                    SubArrayOfLine = np.zeros ((1, LineArray.shape[1]))

    shutil.rmtree(dwarp_path)

#Word Segmentation
def Word_Segmentation():
    for image_file in glob.iglob (line_path + '*.png'):
          #Image Input And Binarization
          LineImage = cv2.imread (image_file,  cv2.IMREAD_UNCHANGED)
          WordArray = LineImage
          #print ("\nOriginal Binarized Line Image Array:", WordArray)

          basename = os.path.basename(image_file)
          name, _ = os.path.splitext(basename)

          #Converting Black Pixels Value To 1 And White Pixel Values To Zero
          for x in range(WordArray.shape[0]):
              for y in range(WordArray.shape[1]):
                  if WordArray[x][y] == 255:
                      WordArray[x][y] = 0
                  else:
                      WordArray[x][y] = 1
          
          Sum_of_col = (np.sum (WordArray, axis=0))
          #print ("\nSum Of Each Column:", Sum_of_col)

          SubArrayOfWord = np.zeros((WordArray.shape[0], 1))
          #print("\nSub Array Of Word:", SubArrayOfWord)

          word = 1
          for i in range (WordArray.shape[1]):
              #Checking The Sum Of Column Being 0 To Seperate The Word Or Else Append The Pixels
              if (Sum_of_col[i] != 0):
                  SubArrayOfWord = np.append (SubArrayOfWord, WordArray[:, i:i + 1], axis=1)
                  if (Sum_of_col[i + 1] == 0) and (Sum_of_col[i + 2] == 0) and (Sum_of_col[i + 3] == 0):
                      #Converting The Black And White Pixels To Its Original Value
                      for x in range (SubArrayOfWord.shape[0]):
                          for y in range (SubArrayOfWord.shape[1]):
                              if SubArrayOfWord[x][y] == 0:
                                SubArrayOfWord[x][y] = 255
                              else:
                                SubArrayOfWord[x][y] = 0

                      #Saving Each Segmented Words Separately And Sequentially In Different Folders
                      w_dir = name + 'word' + str(word)
                      word_path = os.path.join(m_dir, w_dir)   
                      os.mkdir(word_path) 
                      word_path = word_path + '/'

                      pil_image = Image.fromarray(SubArrayOfWord)

                      double_size = (pil_image.size[0]*3, pil_image.size[1]*3)
                      larger_im = pil_image.resize(double_size)

                      pil_image = larger_im.convert('1')
                      wordimg = word_path + name + 'word' + str(word) + '.png'
                      pil_image.save(wordimg, dpi=(OUTPUT_DPI, OUTPUT_DPI))
                      word = word + 1
                      SubArrayOfWord = np.zeros ((WordArray.shape[0], 1))

    shutil.rmtree(line_path)

#Character Segmentation (Removing Matra Of A Word)
def Remove_Matra():
    for folder in os.listdir(m_dir):
        for image_file in glob.iglob (m_dir + folder + '/*.png'):
            WordImage = cv2.imread (image_file,  cv2.IMREAD_UNCHANGED)
            gray = cv2.medianBlur(WordImage, 5)
            WordImage = gray

            MWordArray = WordImage
            MWordArray = WordImage

            basename = os.path.basename(image_file)
            name, _ = os.path.splitext(basename)
            mword_out = m_dir + folder + '/'

            #Converting Black Pixels Value To 1 And White Pixel Values To Zero
            for x in range (MWordArray.shape[0]):
              for y in range (MWordArray.shape[1]):
                  if MWordArray[x][y] == 255:
                      MWordArray[x][y] = 0
                  else:
                      MWordArray[x][y] = 1

            Sum_of_row = (np.sum (MWordArray, axis=1))
            #print ("\nImage Sum Of Each Columns: ", Sum_of_row)

            MaxVal = max (Sum_of_row)
            #print ("Max Value In the Array : ", MaxVal)

            SubArrayOfMWord = np.zeros ((1, MWordArray.shape[1]))

            #Matra Line Of A Word Is Detected By Calculating 50% Pixel Value Of A Word Image
            MatraLine = MWordArray.shape[1] * 0.47
            #print ("\nPixel Value Of Matra", MatraLine)

            Matra = 0
            x = 0
            w = math.ceil(MWordArray.shape[0]/2)+8
            for i in range (w):
              #Checking The Sum Of Column Being Greater Or Equal To 60% Pixel Value To Seperate The Matra Or Else Append The Pixels
              if (Sum_of_row[i] >= MatraLine):
                  Matra - 1
                  #print ("\nDo Nothing As Matra Detected")
              else:
                  SubArrayOfMWord = np.append(SubArrayOfMWord, MWordArray[i:i + 1, :], axis=0)
              x = i

            for i in range (x, MWordArray.shape[0]):
              SubArrayOfMWord = np.append(SubArrayOfMWord, MWordArray[i:i + 1, :], axis=0)

            
            #Converting The Black And White Pixels To Its Original Value
            for x in range (SubArrayOfMWord.shape[0]):
              for y in range (SubArrayOfMWord.shape[1]):
                  if SubArrayOfMWord[x][y] == 0:
                      SubArrayOfMWord[x][y] = 255
                  else:
                      SubArrayOfMWord[x][y] = 0

            pil_image = Image.fromarray(SubArrayOfMWord)
            double_size = (pil_image.size[0]*3, pil_image.size[1]*3)
            larger_im = pil_image.resize(double_size)

            pil_image = larger_im.convert('1')
            wordimg = mword_out + name + '.png'
            pil_image.save(wordimg, dpi=(OUTPUT_DPI, OUTPUT_DPI))
            SubArrayOfMWord = np.zeros ((MWordArray.shape[0], 1))

#Character Segmentation (Seperating Each Character Of A Word)
def Character_Segmentation():
    for folder in os.listdir(m_dir):
        for image_file in glob.iglob (m_dir + folder + '/*.png'):
            MWordImage = cv2.imread (image_file, cv2.IMREAD_UNCHANGED)
            gray = cv2.medianBlur(MWordImage, 5)

            CharacterArray = gray

            basename = os.path.basename(image_file)
            name, _ = os.path.splitext(basename)
            char_out = m_dir + folder + '/'
            cdel = char_out + name + '.png'
            #Converting Black Pixels Value To 1 And White Pixel Values To 0
            for x in range (CharacterArray.shape[0]):
                for y in range (CharacterArray.shape[1]):
                    if CharacterArray[x][y] == 255:
                        CharacterArray[x][y] = 0
                    else:
                        CharacterArray[x][y] = 1

            Sum_of_col = (np.sum(CharacterArray, axis=0))
            #print("\nImage Sum Of Each Columns: ", Sum_of_col)

            SubArrayOfCharacter = np.zeros ((CharacterArray.shape[0], 1))
            #print ("\nSub Array Size Same As No. Of Columns: ", SubArrayOfCharacter)

            #To Detect The Last Column Of The Image
            last_index = CharacterArray.shape[1] - 1

            character = 1
            for i in range (CharacterArray.shape[1]):
                #Checking The Sum Of Column Being 0 To Seperate The Character Or Else Append The Pixels
                if (Sum_of_col[i] != 0):
                    SubArrayOfCharacter = np.append (SubArrayOfCharacter, CharacterArray[:, i:i + 1], axis=1)

                #Checking If Pixel Value Is Less Than Or Equal To 1 Or When The Last Array Index Reached And The Array Has Pixels
                    for x in range (SubArrayOfCharacter.shape[0]):
                        for y in range (SubArrayOfCharacter.shape[1]):
                            #Converting The Black And White Pixels To Its Original Value
                            if SubArrayOfCharacter[x][y] == 0:
                                SubArrayOfCharacter[x][y] = 255
                            else:
                                SubArrayOfCharacter[x][y] = 0

                    #Saving Each Segmented Characters Separately And Sequentially
                    pil_image = Image.fromarray(SubArrayOfCharacter)

                    pil_image = pil_image.convert('1')
                    charimg = char_out + name + 'character' + str(character) + '.png'
                    pil_image.save(charimg, dpi=(OUTPUT_DPI, OUTPUT_DPI))
                    character = character + 1
                    SubArrayOfCharacter = np.zeros ((CharacterArray.shape[0], 1))

            os.remove(cdel)

def main_seg():
    print ("Image Cropping.....")
    Crop_Image()
    print ("Image Dewarping.....")
    Image_dewarp()
    print ("\nLine Segmentation.....")
    Line_Segmentation()
    print ("\nWord Segmentation.....")
    Word_Segmentation()
    print ("\nRemoving Matra.....")
    Remove_Matra()
    print ("\nCharacter Segmentation.....")
    Character_Segmentation()


#if __name__ == '__main__':
#    main()